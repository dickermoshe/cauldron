import 'dart:io';

import 'irs.dart';

const _destination = 'lib/src/time/zone/location_mappings.g.dart';
const _header = '''
// GENERATED CODE - DO NOT MODIFY BY HAND
//
// **************************************************************************
// Generated by: sugar/tool/timezone/main.dart
// **************************************************************************
// 
// ignore_for_file: type=lint

import 'package:meta/meta.dart';

import 'package:sugar/src/time/zone/timezone.dart';
''';


extension LocationMappings on Never {

  static void generate(RootNamespaceIR namespace) {
    final buffer = StringBuffer(_header)..writeln(namespace.toImport())..writeln();
    _function(buffer, namespace);

    File(_destination).writeAsStringSync(buffer.toString());
  }


  static void _function(StringBuffer buffer, RootNamespaceIR namespace) {
    buffer
      ..writeln('/// Returns the [Location] associated with the given [name] if it exists. Otherwise returns the `Factory` [Location].')
      ..writeln('/// ')
      ..writeln('/// ## Implementation details:')
      ..writeln('/// To lazily initialize [Location]s, a switch statement is used instead of a [Map].')
      ..writeln('/// Since most use-cases only require a few [Location]s, it drastically reduces memory footprint.')
      ..writeln('@internal Location parseLocation(String name) {')
      ..writeln('  switch (name) {');
    _cases(buffer, 'Locations', namespace);
    buffer
      ..writeln('    default:')
      ..writeln('      return Locations.factory;')
      ..writeln('  }')
      ..writeln('}');
  }

  static void _cases(StringBuffer buffer, String path, NamespaceIR namespace) {
    for (final location in namespace.locations) {
      buffer
        ..writeln("    case '${location.location.name}':")
        ..writeln('      return $path.${location.variableName};');
    }

    for (final namespace in namespace.namespaces) {
      _cases(buffer, '$path.${namespace.variableName}', namespace);
    }
  }

}
