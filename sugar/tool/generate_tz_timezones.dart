import 'dart:io';

import 'package:path/path.dart';
import 'package:sugar/core.dart';
import 'package:sugar/src/time/offset.dart';
import 'package:timezone/tzdata.dart';

const zoneinfo = '../zoneinfo/';
const destination = 'lib/src/time/zone/generated';

const header = '''

import 'package:sugar/src/time/offset.dart';
import 'package:sugar/src/time/zone/timezone.dart';

// GENERATED CODE - DO NOT MODIFY BY HAND
//
// **************************************************************************
// Generated by: sugar/tool/generate_tz_timezones.dart
// **************************************************************************
// 
// ignore_for_file: type=lint
''';

final separators = RegExp(r'((\s|_)+)|(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])');


void main() {
  final flat = <String, Location>{};
  final namespace = <String, Object>{};

  traverse(Directory(zoneinfo), flat, namespace);
  generate(namespace);
}

void traverse(Directory directory, Map<String, Location> flat, Map<String, Object> namespace) {
  for (final entity in directory.listSync()) {
    final path = relative(entity.path, from: zoneinfo).replaceAll(r'\', '/');
    final name = relative(entity.path, from: directory.path).replaceAll(r'\', '/');

    if (namespace.containsKey(name)) {
      throw StateError('$path already exists');
    }

    if (entity is File) {
      final location = Location.fromBytes(path, entity.readAsBytesSync());
      flat[path] = location;
      namespace[name] = location;

    } else if (entity is Directory) {
      final children = <String, Object>{};
      traverse(entity, flat, children);
      namespace[name] = children;
    }
  }
}


void generate(Map<String, Object> namespace) {
  final imports = <String>[];
  for (final entry in namespace.entries) {
    final name = entry.key;
    final value = entry.value;

    if (value is Map<String, Object>) {
      imports.add(generateNamespaceClass(name, value));
    }
  }

  generateNamespaceExtension(namespace, imports);
}

void generateNamespaceExtension(Map<String, Object> namespace, List<String> imports) {
  final buffer = StringBuffer()
    ..writeAll(imports, '\n')
    ..writeln(header)
    ..writeNamespaceExtension(namespace);
  
  File('lib/src/time/zone/timezones.g.dart').writeAsStringSync(buffer.toString());
}

String generateNamespaceClass(String name, Map<String, Object> namespace) {
  final imports = <String>[];

  for (final entry in namespace.entries) {
    final name = entry.key;
    final value = entry.value;

    if (value is Map<String, Object>) {
      imports.add(generateNamespaceClass(name, value));
    }
  }

  final buffer = StringBuffer()
    ..writeAll(imports, '\n')
    ..writeln(header)
    ..writeNamespaceClass(name, namespace);

  File('$destination/${name.toSnakeCase()}.g.dart').writeAsStringSync(buffer.toString());
  return "import 'package:sugar/src/time/zone/generated/${name.toSnakeCase()}.g.dart';";
}


extension on StringBuffer {

  void writeNamespaceExtension(Map<String, Object> namespace) {
    writeln('extension Timezones on Never {\n');

    final nested = <String>[];
    final locations = <String, Location>{};

    for (final entry in namespace.entries) {
      final name = entry.key;
      final value = entry.value;
  
      if (value is Map<String, Object>) {
      nested.add(name);
  
      } else {
        locations[name] = value as Location;
      }
    }

    nested.forEach(_writeStaticNamespaceClassGetter);
    locations.forEach(_writeStaticTimezoneGetter);

    write('}');
  }
  
  void _writeStaticNamespaceClassGetter(String name) {
    final type = name.toPascalCase();
    writeln('  /// The timezones in `$name`.');
    writeln('  static $type get ${name.toEscapedCamelCase()} => const $type();\n');
  }

  void _writeStaticTimezoneGetter(String name, Location location) {
    this..writeln('  /// The `$name` timezone.')
        ..writeln('  static Timezone get ${name.toEscapedCamelCase()} => const CachedTimezone(')
        ..writeln("    '${location.name}',")
        ..writeln('    ${_transitions(location)}')
        ..writeln('    ${_offsets(location)}')
        ..writeln('  );')
        ..writeln();
  }
  
  
  void writeNamespaceClass(String name, Map<String, Object> namespace) {
    final type = name.toPascalCase();
    this..writeln('class $type {')
        ..writeln()
        ..writeln('  const $type();')
        ..writeln();

    final nested = <String>[];
    final locations = <String, Location>{};

    for (final entry in namespace.entries) {
      final name = entry.key;
      final value = entry.value;

      if (value is Map<String, Object>) {
        nested.add(name);

      } else {
        locations[name] = value as Location;
      }
    }

    nested.forEach(_writeInstanceNamespaceClassGetter);
    locations.forEach(_writeInstanceTimezoneGetter);

    writeln('}');
  }

  void _writeInstanceNamespaceClassGetter(String name) {
    final type = name.toPascalCase();
    writeln('  /// The timezones in `$name`.');
    writeln('  $type get ${name.toEscapedCamelCase()} => const $type();\n');
  }
  
  void _writeInstanceTimezoneGetter(String name, Location location) {
    this..writeln('  /// The `${location.name}` timezone.')
        ..writeln('  Timezone get ${name.toEscapedCamelCase()} => const CachedTimezone(')
        ..writeln("    '${location.name}',")
        ..writeln('    ${_transitions(location)}')
        ..writeln('    ${_offsets(location)}')
        ..writeln('  );')
        ..writeln();
  }

  
  String _transitions(Location location) => 'const [${location.transitionAt.join(', ')}], ';

  String _offsets(Location location) {
    final buffer = StringBuffer('const {\n');

    for (int i = 0; i < location.transitionAt.length; i++) {
      final at = location.transitionAt[i];
      final zone = location.zones[location.transitionZone[i]];

      final offset = "const TimezoneOffset(FastOffset('${format(zone.offset)}', ${zone.offset}), abbreviation: '${location.abbreviations[zone.abbreviationIndex]}', dst: ${zone.isDst})";
      buffer.writeln('      $at: $offset,');
    }

    return (buffer..write('    },')).toString();
  }

}

extension on String {

  String toEscapedCamelCase() => replaceAll(RegExp(r'-(?=\D)'), '_')
    .replaceAll(RegExp(r'-(?=\d)'), 'Minus')
    .replaceAll(RegExp(r'\+(?=\d)'), 'Plus')
    .toCamelCase(separators);

}
